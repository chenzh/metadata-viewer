<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä¿„ç½—æ–¯æ–¹å—</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-user-select: none; user-select: none; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      min-height: 100vh;
      color: white;
    }
    .header { display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 320px; margin-bottom: 10px; }
    h1 { font-size: 1.5rem; }
    .score-box { text-align: right; }
    .score-box span { font-size: 0.8rem; color: #888; }
    .score-box strong { font-size: 1.5rem; display: block; }
    #gameCanvas { border: 2px solid #444; background: #0a0a1a; }
    .controls {
      margin-top: 15px;
      display: grid;
      grid-template-columns: repeat(3, 60px);
      gap: 10px;
      justify-content: center;
    }
    .controls button {
      width: 60px; height: 50px;
      background: #333;
      color: white; border: none;
      border-radius: 8px; font-size: 1.2rem;
      cursor: pointer; touch-action: manipulation;
    }
    .controls button:active { background: #555; }
    .btn-row { grid-column: span 3; display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
    .btn { padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; }
    .btn:hover { background: #45a049; }
    .back-link { margin-top: 15px; color: #888; text-decoration: none; }
    .back-link:hover { color: #fff; }
    @media (max-width: 360px) { #gameCanvas { width: 280px; height: 400px; } }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ® ä¿„ç½—æ–¯æ–¹å—</h1>
    <div class="score-box">
      <span>å¾—åˆ†</span>
      <strong id="score">0</strong>
      <span>ç­‰çº§: <span id="level">1</span></span>
    </div>
  </div>
  <canvas id="gameCanvas" width="300" height="400"></canvas>
  <div class="controls">
    <button onclick="moveLeft()">â†</button>
    <button onclick="rotatePiece()">â†»</button>
    <button onclick="moveRight()">â†’</button>
    <button style="grid-column: 2;" onclick="moveDown()">â†“</button>
  </div>
  <div class="btn-row">
    <button class="btn" onclick="startGame()">æ–°æ¸¸æˆ</button>
  </div>
  <a href="index.html" class="back-link">â† è¿”å›æ¸¸æˆåˆ—è¡¨</a>
  
  <script>
    // ç¦æ­¢é•¿æŒ‰å¤åˆ¶èœå•
    document.addEventListener('contextmenu', e => e.preventDefault());
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const COLS = 10, ROWS = 20, BLOCK_SIZE = 20;
    
    const SHAPES = [
      [[1,1,1,1]], // I
      [[1,1],[1,1]], // O
      [[0,1,0],[1,1,1]], // T
      [[1,0,0],[1,1,1]], // L
      [[0,0,1],[1,1,1]], // J
      [[0,1,1],[1,1,0]], // S
      [[1,1,0],[0,1,1]] // Z
    ];
    const COLORS = ['#00f5ff', '#ffeb3b', '#e040fb', '#ff9100', '#448aff', '#69f0ae', '#ff5252'];
    
    let board = [], currentPiece = null, score = 0, level = 1, gameLoop = null, gameOver = false;
    
    function createBoard() {
      board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
    }
    
    function newPiece() {
      const type = Math.floor(Math.random() * SHAPES.length);
      currentPiece = {
        shape: SHAPES[type],
        color: COLORS[type],
        x: Math.floor(COLS / 2) - Math.floor(SHAPES[type][0].length / 2),
        y: 0
      };
      if (collision(currentPiece, 0, 0)) {
        gameOver = true;
        alert('æ¸¸æˆç»“æŸï¼å¾—åˆ†: ' + score);
      }
    }
    
    function collision(piece, dx, dy) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            const nx = piece.x + x + dx, ny = piece.y + y + dy;
            if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
            if (ny >= 0 && board[ny][nx]) return true;
          }
        }
      }
      return false;
    }
    
    function merge() {
      for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
          if (currentPiece.shape[y][x]) {
            board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
          }
        }
      }
    }
    
    function clearLines() {
      let lines = 0;
      for (let y = ROWS - 1; y >= 0; y--) {
        if (board[y].every(cell => cell !== 0)) {
          board.splice(y, 1);
          board.unshift(Array(COLS).fill(0));
          lines++;
          y++;
        }
      }
      score += lines * 100 * level;
      if (lines > 1) score += lines * 50;
      level = Math.floor(score / 1000) + 1;
      document.getElementById('score').textContent = score;
      document.getElementById('level').textContent = level;
    }
    
    function rotate() {
      const rotated = currentPiece.shape[0].map((_, i) =>
        currentPiece.shape.map(row => row[i]).reverse()
      );
      const original = currentPiece.shape;
      currentPiece.shape = rotated;
      if (collision(currentPiece, 0, 0)) currentPiece.shape = original;
    }
    
    function draw() {
      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid
      ctx.strokeStyle = '#1a1a3a';
      for (let x = 0; x <= COLS; x++) {
        ctx.beginPath(); ctx.moveTo(x * BLOCK_SIZE, 0); ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE); ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        ctx.beginPath(); ctx.moveTo(0, y * BLOCK_SIZE); ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE); ctx.stroke();
      }
      
      // Draw board
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (board[y][x]) {
            ctx.fillStyle = board[y][x];
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
          }
        }
      }
      
      // Draw current piece
      if (currentPiece) {
        ctx.fillStyle = currentPiece.color;
        for (let y = 0; y < currentPiece.shape.length; y++) {
          for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
              ctx.fillRect((currentPiece.x + x) * BLOCK_SIZE, (currentPiece.y + y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            }
          }
        }
      }
    }
    
    function update() {
      if (gameOver) return;
      if (!collision(currentPiece, 0, 1)) {
        currentPiece.y++;
      } else {
        merge();
        clearLines();
        newPiece();
      }
      draw();
    }
    
    function moveLeft() { if (!gameOver && !collision(currentPiece, -1, 0)) { currentPiece.x--; draw(); }}
    function moveRight() { if (!gameOver && !collision(currentPiece, 1, 0)) { currentPiece.x++; draw(); }}
    function moveDown() { if (!gameOver) update(); }
    function rotatePiece() { if (!gameOver) { rotate(); draw(); }}
    
    document.addEventListener('keydown', e => {
      if (gameOver) return;
      switch(e.key) {
        case 'ArrowLeft': case 'a': e.preventDefault(); moveLeft(); break;
        case 'ArrowRight': case 'd': e.preventDefault(); moveRight(); break;
        case 'ArrowDown': case 's': e.preventDefault(); moveDown(); break;
        case 'ArrowUp': case 'w': case ' ': e.preventDefault(); rotatePiece(); break;
      }
    });
    
    function startGame() {
      if (gameLoop) clearInterval(gameLoop);
      createBoard();
      score = 0; level = 1; gameOver = false;
      document.getElementById('score').textContent = '0';
      document.getElementById('level').textContent = '1';
      newPiece();
      gameLoop = setInterval(update, Math.max(100, 500 - level * 30));
      draw();
    }
    
    startGame();
  </script>
</body>
</html>
