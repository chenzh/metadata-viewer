<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>五子棋</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-user-select: none; user-select: none; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      min-height: 100vh;
      color: white;
    }
    h1 { font-size: 1.5rem; margin-bottom: 10px; }
    .info { margin-bottom: 10px; }
    .board {
      width: 350px; height: 350px;
      background: #d4a574;
      position: relative;
      border: 3px solid #8b6914;
    }
    .grid-line {
      position: absolute;
      background: #5d4037;
    }
    .cell {
      position: absolute;
      width: 23px; height: 23px;
      border-radius: 50%;
      cursor: pointer;
      z-index: 10;
    }
    .cell.black { background: radial-gradient(circle at 30% 30%, #666, #000); }
    .cell.white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); border: 1px solid #999; }
    .cell.last { box-shadow: 0 0 8px #ff5252; }
    .controls { display: flex; gap: 10px; margin-top: 15px; }
    .btn { padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; }
    .btn:hover { background: #45a049; }
    .btn.undo { background: #ff9800; }
    .back-link { margin-top: 15px; color: #888; text-decoration: none; }
    @media (max-width: 400px) { .board { width: 320px; height: 320px; } }
  </style>
</head>
<body>
  <h1>⚫ 五子棋 ⚪</h1>
  <p class="info" id="status">黑方回合</p>
  <div class="board" id="board"></div>
  <div class="controls">
    <button class="btn" onclick="newGame()">新游戏</button>
    <button class="btn undo" onclick="undo()">悔棋</button>
  </div>
  <a href="index.html" class="back-link">← 返回游戏列表</a>

  <script>
    // 禁止长按复制菜单
    document.addEventListener('contextmenu', e => e.preventDefault());
    const SIZE = 15, CELL_SIZE = 23.3;
    let board = [], current = 1, gameOver = false, history = [];

    function initBoard() {
      board = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
      current = 1; gameOver = false; history = [];
      document.getElementById('status').textContent = '黑方回合';
      renderBoard();
    }

    function renderBoard() {
      const container = document.getElementById('board');
      container.innerHTML = '';
      
      // Draw grid lines
      for (let i = 0; i < SIZE; i++) {
        const h = document.createElement('div');
        h.className = 'grid-line';
        h.style.width = '100%';
        h.style.height = '1px';
        h.style.top = (i * CELL_SIZE + CELL_SIZE/2) + 'px';
        h.style.left = '0';
        container.appendChild(h);
        
        const v = document.createElement('div');
        v.className = 'grid-line';
        v.style.width = '1px';
        v.style.height = '100%';
        v.style.left = (i * CELL_SIZE + CELL_SIZE/2) + 'px';
        v.style.top = '0';
        container.appendChild(v);
      }
      
      // Draw stones
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c]) {
            const stone = document.createElement('div');
            stone.className = 'cell ' + (board[r][c] === 1 ? 'black' : 'white');
            if (history.length > 0 && history[history.length - 1].r === r && history[history.length - 1].c === c) {
              stone.classList.add('last');
            }
            stone.style.left = (c * CELL_SIZE + 2) + 'px';
            stone.style.top = (r * CELL_SIZE + 2) + 'px';
            container.appendChild(stone);
          }
        }
      }
      
      // Click areas
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const clickArea = document.createElement('div');
          clickArea.style.position = 'absolute';
          clickArea.style.left = (c * CELL_SIZE) + 'px';
          clickArea.style.top = (r * CELL_SIZE) + 'px';
          clickArea.style.width = CELL_SIZE + 'px';
          clickArea.style.height = CELL_SIZE + 'px';
          clickArea.onclick = () => placeStone(r, c);
          container.appendChild(clickArea);
        }
      }
    }

    function placeStone(r, c) {
      if (gameOver || board[r][c]) return;
      
      board[r][c] = current;
      history.push({ r, c, player: current });
      
      if (checkWin(r, c)) {
        gameOver = true;
        document.getElementById('status').textContent = (current === 1 ? '黑方' : '白方') + '获胜！';
        setTimeout(() => alert((current === 1 ? '⚫ 黑方' : '⚪ 白方') + '获胜！'), 100);
      } else {
        current = 3 - current;
        document.getElementById('status').textContent = (current === 1 ? '黑方' : '白方') + '回合';
        if (current === 2 && !gameOver) setTimeout(aiMove, 300);
      }
      renderBoard();
    }

    function aiMove() {
      if (gameOver) return;
      
      // Try to win
      let move = findWinningMove(2);
      if (move) { placeStone(move.r, move.c); return; }
      
      // Block opponent
      move = findWinningMove(1);
      if (move) { placeStone(move.r, move.c); return; }
      
      // Random move
      const empty = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (!board[r][c]) empty.push({ r, c });
        }
      }
      if (empty.length > 0) {
        const m = empty[Math.floor(Math.random() * empty.length)];
        placeStone(m.r, m.c);
      }
    }

    function findWinningMove(player) {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (!board[r][c]) {
            board[r][c] = player;
            const win = checkWin(r, c);
            board[r][c] = 0;
            if (win) return { r, c };
          }
        }
      }
      return null;
    }

    function checkWin(r, c) {
      const p = board[r][c];
      const dirs = [[1,0], [0,1], [1,1], [1,-1]];
      for (const [dr, dc] of dirs) {
        let count = 1;
        for (let i = 1; i < 5; i++) {
          const nr = r + dr * i, nc = c + dc * i;
          if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nr][nc] === p) count++;
          else break;
        }
        for (let i = 1; i < 5; i++) {
          const nr = r - dr * i, nc = c - dc * i;
          if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nr][nc] === p) count++;
          else break;
        }
        if (count >= 5) return true;
      }
      return false;
    }

    function undo() {
      if (history.length >= 2) {
        const h1 = history.pop();
        const h2 = history.pop();
        board[h1.r][h1.c] = 0;
        board[h2.r][h2.c] = 0;
        current = 1;
        document.getElementById('status').textContent = '黑方回合';
        renderBoard();
      }
    }

    function newGame() { initBoard(); }

    initBoard();
  </script>
</body>
</html>
