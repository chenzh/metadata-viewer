<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è¿·å®«</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      min-height: 100vh;
      color: white;
    }
    h1 { font-size: 1.5rem; margin-bottom: 10px; }
    .info { display: flex; gap: 30px; margin-bottom: 10px; }
    #gameCanvas { border: 3px solid #444; }
    .controls {
      display: grid;
      grid-template-columns: repeat(3, 60px);
      gap: 8px;
      margin-top: 15px;
    }
    .controls button {
      width: 60px; height: 50px;
      background: #333; color: white;
      border: none; border-radius: 8px;
      font-size: 1.2rem; cursor: pointer;
    }
    .btn { margin-top: 15px; padding: 10px 25px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; }
    .back-link { margin-top: 15px; color: #888; text-decoration: none; }
    @media (max-width: 400px) { #gameCanvas { width: 320px; height: 320px; } }
  </style>
</head>
<body>
  <h1>ğŸŒ€ è¿·å®«</h1>
  <div class="info">
    <span>æ­¥æ•°: <strong id="steps">0</strong></span>
    <span>æ—¶é—´: <strong id="time">0</strong>s</span>
  </div>
  <canvas id="gameCanvas" width="360" height="360"></canvas>
  <div class="controls">
    <button style="grid-column: 2;" onclick="move(0, -1)">â†‘</button>
    <button onclick="move(-1, 0)">â†</button>
    <button onclick="move(0, 1)">â†“</button>
    <button onclick="move(1, 0)">â†’</button>
  </div>
  <button class="btn" onclick="newGame()">æ–°æ¸¸æˆ</button>
  <a href="index.html" class="back-link">â† è¿”å›æ¸¸æˆåˆ—è¡¨</a>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const SIZE = 15, CELL = 24;
    
    let maze = [], player = { x: 0, y: 0 }, exit = { x: 0, y: 0 },
        steps = 0, timer = 0, interval = null, path = [];
    
    function generateMaze() {
      maze = Array(SIZE).fill(null).map(() => Array(SIZE).fill(1));
      const stack = [];
      let cx = 0, cy = 0;
      maze[cy][cx] = 0;
      
      do {
        const neighbors = [];
        [[0,-2],[0,2],[-2,0],[2,0]].forEach(([dx,dy]) => {
          const nx = cx + dx, ny = cy + dy;
          if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && maze[ny][nx]) {
            neighbors.push({ x: nx, y: ny, dx: dx/2, dy: dy/2 });
          }
        });
        
        if (neighbors.length > 0) {
          const n = neighbors[Math.floor(Math.random() * neighbors.length)];
          stack.push({ x: cx, y: cy });
          maze[cy + n.dy][cx + n.dx] = 0;
          maze[n.y][n.x] = 0;
          cx = n.x; cy = n.y;
        } else if (stack.length > 0) {
          const s = stack.pop();
          cx = s.x; cy = s.y;
        }
      } while (stack.length > 0);
      
      // Ensure start and end are open
      maze[0][0] = 0;
      maze[SIZE-1][SIZE-1] = 0;
      if (SIZE > 2) maze[SIZE-1][SIZE-2] = 0;
      
      player = { x: 0, y: 0 };
      exit = { x: SIZE-1, y: SIZE-1 };
      steps = 0; timer = 0; path = [];
      clearInterval(interval);
      interval = setInterval(() => {
        timer++;
        document.getElementById('time').textContent = timer;
      }, 1000);
      draw();
    }
    
    function draw() {
      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          if (maze[y][x] === 0) {
            ctx.fillStyle = '#2a2a4e';
            ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
          } else {
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
          }
        }
      }
      
      // Exit
      ctx.fillStyle = '#4CAF50';
      ctx.fillRect(exit.x * CELL + 2, exit.y * CELL + 2, CELL - 4, CELL - 4);
      
      // Player
      ctx.fillStyle = '#ffeb3b';
      ctx.beginPath();
      ctx.arc(player.x * CELL + CELL/2, player.y * CELL + CELL/2, CELL/3, 0, Math.PI * 2);
      ctx.fill();
      
      // Trail
      ctx.fillStyle = 'rgba(255,235,59,0.3)';
      path.forEach(p => {
        ctx.fillRect(p.x * CELL + 4, p.y * CELL + 4, CELL - 8, CELL - 8);
      });
    }
    
    function move(dx, dy) {
      const nx = player.x + dx, ny = player.y + dy;
      if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && maze[ny][nx] === 0) {
        path.push({ x: player.x, y: player.y });
        player.x = nx;
        player.y = ny;
        steps++;
        document.getElementById('steps').textContent = steps;
        draw();
        
        if (player.x === exit.x && player.y === exit.y) {
          clearInterval(interval);
          setTimeout(() => alert(`ğŸ‰ æ­å–œé€ƒå‡ºè¿·å®«ï¼\næ­¥æ•°: ${steps}\næ—¶é—´: ${timer}ç§’`), 100);
        }
      }
    }
    
    document.addEventListener('keydown', e => {
      switch(e.key) {
        case 'ArrowUp': case 'w': e.preventDefault(); move(0, -1); break;
        case 'ArrowDown': case 's': e.preventDefault(); move(0, 1); break;
        case 'ArrowLeft': case 'a': e.preventDefault(); move(-1, 0); break;
        case 'ArrowRight': case 'd': e.preventDefault(); move(1, 0); break;
      }
    });
    
    function newGame() {
      document.getElementById('steps').textContent = '0';
      document.getElementById('time').textContent = '0';
      generateMaze();
    }
    
    newGame();
  </script>
</body>
</html>
